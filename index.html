<!DOCTYPE html>
<html lang="it">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Hyprland Terminal</title>
		<style>
		:root{
			--arch-blue: #1793d1;
			--bg-1: #0b0f10;
			--bg-2: #0e1416;
			--fg: #cdd6f4;
			--fg-dim: #9aa5b1;
			--accent: var(--arch-blue);
			--radius: 16px;
			--border-w: 2px;
			--ascii-w-ch: 28;
		}

		* { box-sizing: border-box; }
		html, body { height: 100%; }
		body {
			margin: 0;
			background: radial-gradient(1200px 800px at 70% 20%, #0e1620 0%, #0a0f14 45%, #070a0d 100%);
			color: var(--fg);
			font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", "JetBrains Mono", "Fira Code", monospace;
			overflow: hidden;
		}

		.desktop {
			position: fixed; inset: 0;
			display: grid; place-items: center;
			padding: 2vh;
		}

		.window {
			width: 95vw;
			height: 90vh;
			max-width: 1400px;
			max-height: 900px;
			background: linear-gradient(180deg, var(--bg-2) 0%, var(--bg-1) 100%);
			border: var(--border-w) solid var(--accent);
			border-radius: var(--radius);
			box-shadow:
				0 0 0 2px rgba(23,147,209,0.15) inset,
				0 0 24px rgba(23,147,209,0.25),
				0 32px 120px -30px rgba(0,0,0,0.6);
			overflow: clip;
			transform-origin: 50% 50%;
			opacity: 0;
			transform: translateY(28px) scale(0.96);
			will-change: transform, opacity;
		}

		.terminal {
			overflow: hidden auto;
			scrollbar-width: none;
			-ms-overflow-style: none;
			height: 100%;
			padding: 14px 16px;
			background:
				radial-gradient(900px 480px at 20% 0%, rgba(23,147,209,0.10), transparent 60%) no-repeat,
				radial-gradient(700px 420px at 90% 120%, rgba(23,147,209,0.06), transparent 60%) no-repeat;
			color: var(--fg);
			font-size: 14px;
			line-height: 1.4;
			overflow: hidden auto;
		}

		.terminal::-webkit-scrollbar {
			width: 0;
			height: 0;
		}

				/* allow long lines to wrap instead of causing horizontal overflow
				   keep ASCII art (ff-ascii) as pre so it stays monospaced */
				.line { white-space: pre-wrap; overflow-wrap: anywhere; word-break: break-word; }
		.newLine { margin-top: 10px;}
		.muted { color: var(--fg-dim); }

		.prompt { color: #8bd5ff; }
		.host { color: #89dceb; }
		.path { color: #a6e3a1; }

		/* fastfetch: alligned grid */
		.ff-row {
			display: grid;
			grid-template-columns: calc(var(--ascii-w-ch) * 1ch) 1fr;
			column-gap: 2ch;
			white-space: normal;
		}
		.ff-ascii {
			white-space: pre;
			color: var(--accent);
			filter: drop-shadow(0 0 6px rgba(23,147,209,.35));
		}
				/* info column: on wide/tablet/desktop keep single-line with ellipsis; on small screens allow wrap */
				.ff-info { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
		.ff-label { color: #8bd5ff; }
		.ff-value { color: #cdd6f4; }

				/* menu buttons (mobile-friendly) - hidden by default, only shown on small screens */
				.menu-buttons { margin-top: 10px; display: none; gap: 10px; }
				.menu-buttons button {
					background: var(--accent);
					color: var(--fg);
					border: none;
					padding: 8px 12px;
					border-radius: 8px;
					font-size: 14px;
					cursor: pointer;
				}

				@media (max-width: 700px) {
					.menu-buttons { display: flex; flex-direction: column; }
					.menu-buttons button { width: 100%; padding: 12px 14px; font-size: 16px; }
					/* mobile fastfetch: stack logo then specs */
					.ff-ascii-mobile { white-space: pre; text-align: left; color: var(--accent); filter: drop-shadow(0 0 6px rgba(23,147,209,.35)); margin-bottom: 8px; font-family: ui-monospace, Menlo, monospace; }
					.ff-spec { white-space: normal; margin: 6px 0; }
					/* on mobile allow the info column to wrap */
					.ff-info { white-space: pre-wrap; overflow-wrap: anywhere; }
				}

				/* invisible input used to summon virtual keyboard on touch devices */
				.virtual-input { position: fixed; left: 8px; bottom: 8px; width: 1px; height: 1px; opacity: 0; border: none; padding: 0; margin: 0; z-index: 9999; }

		.cursor {
			display: inline-block;
			width: 8px; height: 1.15em;
			vertical-align: -0.15em;
			margin-left: 2px;
			background: var(--fg);
			opacity: 0.9;
			animation: blink 1s steps(1, end) infinite;
		}
		@keyframes blink { 0%,49%{opacity:0} 50%,100%{opacity:.9} }

		/* In/out Hyprland-like */
		@keyframes hypr-pop {
		0%   { opacity: 0; transform: translateY(28px) scale(0.96); filter: saturate(0.9); }
		60%  { opacity: 1; transform: translateY(-4px) scale(1.008); }
		85%  { transform: translateY(1px) scale(0.998); }
		100% { opacity: 1; transform: translateY(0) scale(1); filter: saturate(1); }
		}
		.animate-in { animation: hypr-pop 520ms cubic-bezier(.2,.8,.2,1) forwards; }

		@keyframes hypr-out {
		0%   { opacity: 1; transform: translateY(0) scale(1); filter: saturate(1); }
		100% { opacity: 0; transform: translateY(24px) scale(0.96); filter: saturate(0.9); }
		}
		.animate-out { animation: hypr-out 360ms cubic-bezier(.2,.8,.2,1) forwards; }

		@media (prefers-reduced-motion: reduce) {
			.window { opacity: 1; transform: none; animation: none !important; }
			.cursor { animation: none !important; opacity: 1; }
		}
		</style>
	</head>
	<body>
		<div class="desktop">
			<div class="window" id="win">
				<div class="terminal" id="term" role="document" aria-label="Terminale"></div>
			</div>
		</div>

		<script>
		(function() {
			const params = new URLSearchParams(location.search);
			const raw = params.get('name') || '';
			const user = sanitizeUsername(raw) || 'user';

			// Edit these constants directly in the code to change the fake fastfetch
			// values or the SSH target. Only the `name` URL parameter is read.
			const CONFIG = {
				ip: '36.21.587.914',
				port: '57237',
				fastfetch: {
					// Example/default values — edit these constants in the file
					OS: 'Arch Linux x86_64',
					Host: 'archlinux',
					Shell: 'zsh 5.9',
					WM: 'Hyprland',
					Terminal: '/dev/tty1',
					Font: 'VGA default kernel font 8x16x256',
					Display1: 'HP M24f FHD',
					Display1Info: '1920x1080 in 25\", 60 Hz [External]',
					CPU: 'AMD Ryzen 7 5800X (16) @ 4.85 GHz',
					GPU: 'NVIDIA GeForce RTX 3060 Lite Hash Rate [Discrete]',
					Memory: '1.18 GiB / 31.22 GiB (4%)',
					Swap: '0 B / 16.00 GiB (3%)',
					DiskRoot: '334.73 GiB / 441.14 GiB (76%) - ext4',
					LocalIP: '192.168.1.84/24',
					Locale: 'en_US.UTF-8',
					Packages: 1058
				}
			};

			const PATHS = {
				QBTORRENT: 'qbtorrent.html',
				FILES: 'files.html'
			};

			// Modular menu definition: add items here to extend the menu easily.
			// Each entry: { id: 'qbtorrent', label: 'qbtorrent', path: PATHS.QBTORRENT, aliases: ['1','qbt','qbtorrent'] }
			const MENU = [
				{ id: 'qbtorrent', label: 'qbtorrent', path: PATHS.QBTORRENT, aliases: ['1','qbt','qbtorrent','qbittorrent'] },
				{ id: 'files', label: 'files', path: PATHS.FILES, aliases: ['2','files','file','f'] }
			];
			const BASE = new URL('.', location.href).href;

			document.title = `Terminal — ${user}@archlinux`;

			const win = document.getElementById('win');
			const term = document.getElementById('term');

			// invisible input to summon on-screen keyboard on touch devices (tablets/phones)
			const virtualInput = document.createElement('input');
			virtualInput.type = 'text';
			virtualInput.className = 'virtual-input';
			virtualInput.autocapitalize = 'none';
			virtualInput.autocomplete = 'off';
			virtualInput.spellcheck = false;
			document.body.appendChild(virtualInput);

			// when the virtual input receives keys, forward them to the terminal inputState
			virtualInput.addEventListener('keydown', (e) => {
				if (!inputState.active) {
					// start an interactive prompt if none exists
					startInteractiveInput(user, handleMenuSelection);
				}
				// mirror existing keyboard behavior
				if (e.key === 'Enter') {
					e.preventDefault();
					const text = inputState.buffer;
					inputState.active = false;
					inputState.onEnter && inputState.onEnter(text);
					virtualInput.value = '';
					return;
				}
				if (e.key === 'Backspace') {
					e.preventDefault();
					inputState.buffer = inputState.buffer.slice(0, -1);
					if (inputState.target) inputState.target.textContent = inputState.buffer;
					virtualInput.value = '';
					return;
				}
				if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
					// printable characters
					e.preventDefault();
					inputState.buffer += e.key;
					if (inputState.target) inputState.target.textContent = inputState.buffer;
					virtualInput.value = '';
				}
			});

			// focus virtual input on touch inside terminal for touch devices above mobile
			term.addEventListener('touchstart', (ev) => {
				if (window.matchMedia && window.matchMedia('(max-width:700px)').matches) return; // mobile shows buttons
				virtualInput.focus();
			});

			// input state
			const inputState = { active: false, buffer: '', target: null, cursor: null, onEnter: null };

			setTimeout(() => {
				win.classList.add('animate-in');
				setTimeout(() => {
					renderFastfetch(user);
					setTimeout(() => simulateSSH(user), 280);
				}, 140);
			}, 60);

			/* ---------- Prompt e typing ---------- */
			function newPrompt(u, editable=false) {
				// remove any existing cursor so only the newest prompt shows it
				const existingCursors = term.querySelectorAll('.cursor');
				existingCursors.forEach(c => c.parentNode && c.parentNode.removeChild(c));

				const line = document.createElement('div');
				line.className = 'line newLine';
				// only include the typed input and cursor when the prompt is editable
				const typedHTML = editable ? '<span class="typed"></span>' : '';
				const cursorHTML = editable ? '<span class="cursor" aria-hidden="true"></span>' : '';
				line.innerHTML =
					'<span class="prompt"><span class="user">'+u+
						'</span>@<span class="host">archlinux</span></span>:'+
						'<span class="path">~</span>$ ' +
						typedHTML + cursorHTML;
				term.appendChild(line);
				scrollToBottom();
				return {
					line,
					typedTarget: editable ? line.querySelector('.typed') : null,
					cursor: editable ? line.querySelector('.cursor') : null
				};
			}

			function typeOut(el, text, speed, done) {
				let i = 0;
				const id = setInterval(() => {
					el.textContent += text[i++];
					scrollToBottom();
					if (i >= text.length) { clearInterval(id); done && done(); }
				}, speed);
			}

			function removeCursor(cur) {
				if (cur && cur.parentNode) cur.parentNode.removeChild(cur);
			}

			/* ---------- fastfetch ---------- */
			function labelVal(label, value) {
				return '<span class="ff-label">'+label+':</span> <span class="ff-value">'+value+'</span>';
			}

			function appendRaw(text) {
				const line = document.createElement('div');
				line.className = 'line';
				line.textContent = text;
				term.appendChild(line);
				scrollToBottom();
			}

			// append a line that may contain HTML (used for colored test blocks)
			function appendHTML(html) {
				const line = document.createElement('div');
				line.className = 'line';
				line.innerHTML = html;
				term.appendChild(line);
				scrollToBottom();
			}

			function appendAsciiInfo(leftText, rightHTML) {
				const row = document.createElement('div');
				row.className = 'ff-row';
				const left = document.createElement('span');
				left.className = 'ff-ascii';
				left.textContent = leftText;
				const right = document.createElement('span');
				right.className = 'ff-info';
				if (rightHTML) right.innerHTML = rightHTML;
				row.appendChild(left);
				row.appendChild(right);
				term.appendChild(row);
				scrollToBottom();
			}

			// Like appendAsciiInfo but allow HTML in the left (ASCII) column.
			function appendAsciiHTML(leftHTML, rightHTML) {
				const row = document.createElement('div');
				row.className = 'ff-row';
				const left = document.createElement('span');
				left.className = 'ff-ascii';
				if (leftHTML) left.innerHTML = leftHTML;
				const right = document.createElement('span');
				right.className = 'ff-info';
				if (rightHTML) right.innerHTML = rightHTML;
				row.appendChild(left);
				row.appendChild(right);
				term.appendChild(row);
				scrollToBottom();
			}

			function renderFastfetch(u) {
				const ascii = [
					'                   -`',
					'                  .o+`',
					'                 `ooo/',
					'                `+oooo:',
					'               `+oooooo:',
					'               -+oooooo+:',
					'             `/:-:++oooo+:',
					'            `/++++/+++++++:',
					'           `/++++++++++++++:',
					'          `/+++ooooooooooooo/',
					'         ./ooosssso++osssssso+',
					'        .oossssso-````/ossssss+',
					'       -osssssso.      :ssssssso.',
					'      :osssssss/        osssso+++.',
					'     /ossssssss/        +ssssooo/-',
					'   `/ossssso+/:-        -:/+osssso+-',
					'  `+sso+:-`                 `.-/+oso:',
					' `++:.                           `-/+/',
					' .`                                 `/.'
				];
				const maxLen = ascii.reduce((m, s) => Math.max(m, s.length), 0);
				document.documentElement.style.setProperty('--ascii-w-ch', String(maxLen));

				const info = {
					0:  labelVal('OS', CONFIG.fastfetch.OS),
					1:  labelVal('Host', CONFIG.fastfetch.Host),
					2:  labelVal('Kernel', guessKernel()),
					3:  labelVal('Uptime', guessUptime()),
					4:  labelVal('Packages', CONFIG.fastfetch.Packages + ' (pacman)'),
					5:  labelVal('Shell', CONFIG.fastfetch.Shell),
					6:  labelVal('Display (' + CONFIG.fastfetch.Display1 + ')', CONFIG.fastfetch.Display1Info),
					7: labelVal('Terminal', CONFIG.fastfetch.Terminal),
					8: labelVal('Terminal Font', CONFIG.fastfetch.Font),
					9: labelVal('CPU', CONFIG.fastfetch.CPU),
					10: labelVal('GPU', CONFIG.fastfetch.GPU),
					11: labelVal('Memory', CONFIG.fastfetch.Memory),
					12: labelVal('Swap', CONFIG.fastfetch.Swap),
					13: labelVal('Disk (/)', CONFIG.fastfetch.DiskRoot),
					14: labelVal('Local IP (wlp6s0)', CONFIG.fastfetch.LocalIP),
					15: labelVal('Locale', CONFIG.fastfetch.Locale)
				};

				// build fastfetch content inside a temporary container with its own line-height
				const ffContainer = document.createElement('div');
				ffContainer.style.lineHeight = 'normal';
				
				const appendRawLocal = (text) => {
					const line = document.createElement('div');
					line.className = 'line';
					line.textContent = text;
					ffContainer.appendChild(line);
				};
				const appendHTMLLocal = (html) => {
					const line = document.createElement('div');
					line.className = 'line';
					line.innerHTML = html;
					ffContainer.appendChild(line);
				};
				const appendAsciiInfoLocal = (leftText, rightHTML) => {
					const row = document.createElement('div');
					row.className = 'ff-row';
					const left = document.createElement('span');
					left.className = 'ff-ascii';
					left.textContent = leftText;
					const right = document.createElement('span');
					right.className = 'ff-info';
					if (rightHTML) right.innerHTML = rightHTML;
					row.appendChild(left);
					row.appendChild(right);
					ffContainer.appendChild(row);
				};

				appendRawLocal('');
				// prepare the color HTML so we can insert it right after the last info row
				const swatch = (color, w=22, h=18) =>
					`<span style="display:inline-block;width:${w}px;height:${h}px;background:${color};margin-left:0;border:1px solid rgba(0,0,0,0.28);box-sizing:border-box;vertical-align:middle"></span>`;
				const firstRow = ['#000000','#cc0000','#4e9a06','#c4a000','#3465a4','#75507b','#06989a','#d3d7cf'];
				const secondRow = ['#555753','#ef2929','#8ae234','#fce94f','#729fcf','#ad7fa8','#34e2e2','#eeeeec'];
				const makeRow = (colors) => {
					let blocks = '';
					for (let i = 0; i < colors.length; i++) {
						const c = colors[i];
						blocks += `<span style="display:inline-block;width:22px;height:18px;background:${c};margin-left:${i?'-1px':'0'};border:1px solid rgba(0,0,0,0.28);box-sizing:border-box;vertical-align:middle"></span>`;
					}
					return '<span style="display:inline-block;vertical-align:middle">' + blocks + '</span>';
				};
				const rightHtml = '<div style="line-height:0">' + makeRow(firstRow) + '<div style="height:4px"></div>' + makeRow(secondRow) + '</div>';
				// insert colors immediately after the last info row (so they're below the specs)
				// but keep ASCII art continuity on the left. We'll leave a blank RIGHT cell
				// (i.e. blank line in the info column) and then place the palette on the next
				// ASCII row's right cell so the left column still shows the logo.
				const infoIndices = Object.keys(info).map(n => parseInt(n, 10)).filter(n => !isNaN(n));
				const lastInfoIndex = infoIndices.length ? Math.max(...infoIndices) : -1;
				let colorsInserted = false;
				// we want: blank right-cell, then first palette row, then second palette row,
				// while keeping ASCII art continuous on the left for all these rows.
				const sepIndex = lastInfoIndex + 1; // blank separator row
				const firstPaletteIndex = lastInfoIndex + 2;
				const secondPaletteIndex = lastInfoIndex + 3;

				// On small screens we stack the logo on top and list specs and colors vertically
				const isMobile = window.matchMedia && window.matchMedia('(max-width:700px)').matches;
				if (isMobile) {
					// logo at the top
					appendHTMLLocal('<pre class="ff-ascii-mobile">' + ascii.join('\n') + '</pre>');
					// specs below: one per line
					const infoOrder = Object.keys(info).map(n => parseInt(n,10)).filter(n => !isNaN(n)).sort((a,b)=>a-b);
					infoOrder.forEach(i => {
						const label = info[i] ? stripTags(info[i]) : '';
						appendRawLocal(label);
					});
					// blank separator
					appendRawLocal('');
					// colors: show two stacked rows like desktop view (no hex labels)
					appendHTMLLocal(makeRow(firstRow));
					appendHTMLLocal('<div style="height:4px"></div>');
					appendHTMLLocal(makeRow(secondRow));
					colorsInserted = true;
				} else {
					ascii.forEach((left, i) => {
						if (i <= lastInfoIndex) {
							appendAsciiInfoLocal(left, info[i] || '');
							return;
						}

						if (i === sepIndex) {
							// blank right cell to separate specs from palette
							appendAsciiInfoLocal(left, '');
							return;
						}

						if (i === firstPaletteIndex) {
							appendAsciiInfoLocal(left, makeRow(firstRow));
							return;
						}

						if (i === secondPaletteIndex) {
							appendAsciiInfoLocal(left, makeRow(secondRow));
							colorsInserted = true;
							return;
						}

						// default: just append the ASCII line with whatever info exists (usually empty)
						appendAsciiInfoLocal(left, info[i] || '');
					});
				}

				// fallback: if for some reason we didn't insert colors (not enough ascii lines), append them at the end
				if (!colorsInserted) {
					appendRawLocal('');
					appendAsciiInfoLocal('', makeRow(firstRow));
					appendAsciiInfoLocal('', makeRow(secondRow));
				}

				// finally attach the fastfetch container into the terminal
				term.appendChild(ffContainer);
				scrollToBottom();
			}

			// utility: strip HTML tags for mobile plain-text specs
			function stripTags(html) {
				return (html || '').replace(/<[^>]+>/g, '');
			}

			// show two big buttons (qbtorrent / files) instead of typing input
			function showMenuButtons(u) {
				const container = document.createElement('div');
				container.className = 'menu-buttons';
				// build buttons from MENU array so adding items is easy
				MENU.forEach((item, idx) => {
					const b = document.createElement('button');
					b.textContent = item.label;
					b.addEventListener('click', () => {
						container.remove();
						appendRaw('');
						appendRaw('Starting ' + item.label + ' ...');
						const url = BASE + item.path + '?name=' + encodeURIComponent(u);
						navigateWithTransition(url);
					});
					container.appendChild(b);
				});
				term.appendChild(container);
				scrollToBottom();
			}

			/* ---------- SSH + menu ---------- */
			function simulateSSH(u) {
				// prompt that writes the ssh command
				const p = newPrompt(u, true);
				const cmd = `ssh -p ${CONFIG.port} ${u}@${CONFIG.ip}`;
				typeOut(p.typedTarget, cmd, 14, () => {
					removeCursor(p.cursor);
					appendRaw('');
					appendRaw('Connecting to ' + CONFIG.ip + ':' + CONFIG.port + ' as ' + u + ' ...');
					setTimeout(() => {
						appendRaw('Connection established.');
						appendRaw('');
						appendRaw('Select a service and press Enter:');
						// print menu items (numbered) from MENU so it's easy to extend
						MENU.forEach((item, idx) => {
							appendRaw('  [' + (idx+1) + '] ' + item.label);
						});
						appendRaw('');
						// on mobile show buttons; on desktop keep keyboard prompt
						if (window.matchMedia && window.matchMedia('(max-width:700px)').matches) {
							showMenuButtons(u);
						} else {
							startInteractiveInput(u, handleMenuSelection);
						}
					}, 220);
				});
			}

			function startInteractiveInput(u, onEnter) {
				// new interactive prompt
				const p = newPrompt(u, true);
				inputState.active = true;
				inputState.buffer = '';
				inputState.target = p.typedTarget;
				inputState.cursor = p.cursor;
				inputState.onEnter = onEnter;
			}

			function handleMenuSelection(text) {
				const v = (text || '').trim().toLowerCase();
				// find menu item by numeric index or alias
				let found = null;
				if (/^\d+$/.test(v)) {
					const idx = parseInt(v,10) - 1;
					if (MENU[idx]) found = MENU[idx];
				} else {
					for (const item of MENU) {
						for (const a of (item.aliases || [])) {
							if (a.toLowerCase() === v) { found = item; break; }
						}
						if (found) break;
						// also allow simple name match or startsWith
						if (item.label.toLowerCase() === v || item.label.toLowerCase().startsWith(v)) { found = item; break; }
					}
				}
				if (!found) {
					appendRaw('Invalid command. Type the number or name of an option.');
					startInteractiveInput(user, handleMenuSelection);
					return;
				}
				inputState.active = false;
				if (inputState.cursor) removeCursor(inputState.cursor);

				const url = BASE + found.path + '?name=' + encodeURIComponent(user);
				appendRaw('');
				appendRaw('Starting ' + found.label + ' ...');
				navigateWithTransition(url);
			}

			// keyboard capture for the fake prompt
			document.addEventListener('keydown', (e) => {
				if (!inputState.active) return;
				if (e.key === 'Enter') {
					e.preventDefault();
					const text = inputState.buffer;
					inputState.active = false;
					inputState.onEnter && inputState.onEnter(text);
					return;
				}
				if (e.key === 'Backspace') {
					e.preventDefault();
					inputState.buffer = inputState.buffer.slice(0, -1);
					inputState.target.textContent = inputState.buffer;
					scrollToBottom();
					return;
				}
				if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
					// printable characters
					inputState.buffer += e.key;
					inputState.target.textContent = inputState.buffer;
					scrollToBottom();
				}
			});

			function navigateWithTransition(url) {
				win.classList.remove('animate-in');
				win.classList.add('animate-out');
				setTimeout(() => { location.href = url; }, 360);
			}

			/* ---------- util ---------- */
			function scrollToBottom() { term.scrollTop = term.scrollHeight; }
			function sanitizeUsername(s) {
				const trimmed = (s || '').trim();
				const m = trimmed.match(/[A-Za-z0-9._-]{1,32}/g);
				if (!m) return '';
				return m.join('').slice(0, 32);
			}

			// fake fastfetch values
			function guessKernel() { return 'Linux 6.' + (6 + Math.floor(Math.random()*3)) + '.0'; }
			function guessUptime() {
				const ms = performance.now();
				const m = Math.floor(ms / 60000);
				const h = Math.floor(m / 60);
				const mm = m % 60;
				return (h ? h+'h ' : '') + mm + 'm';
			}
			function guessPackages() { return 1200 + Math.floor(Math.random()*150); }
			function guessCPU() {
				try { return (navigator.hardwareConcurrency || 4) + 'x CPU cores'; }
				catch { return 'CPU'; }
			}
			function guessMemory() {
				const gb = (navigator.deviceMemory || 8);
				const used = (gb * (0.35 + Math.random()*0.25)).toFixed(1);
				return used + ' GiB / ' + gb + ' GiB';
			}
		})();
		</script>
	</body>
</html>
